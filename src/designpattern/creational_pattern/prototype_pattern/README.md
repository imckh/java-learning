# 对象的克隆 原型模式-Prototype Pattern

原型模式(Prototype Pattern)：

使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。

原型模式的工作原理很简单：
将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。
由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，
因此原型模式在真实开发中的使用频率还是非常高的。
原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。

## [v0](v0) 通用实现方法

通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，
并将相关的参数传入新创建的对象中，保证它们的成员属性相同。

### Java语言提供的clone()方法

Object类提供一个clone()方法，可以将一个Java对象复制一份。
因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。

需要注意的是能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持被复制。
如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。

Java语言中的clone()方法满足：
> 1. 对任何对象x，都有x.clone() != x，即克隆对象与原型对象不是同一个对象；
> 2. 对任何对象x，都有x.clone().getClass() == x.getClass()，即克隆对象与原型对象的类型一样；
> 3. 如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。

为了获取对象的一份拷贝，我们可以直接利用Object类的clone()方法，具体步骤如下：
> 1. 在派生类中覆盖基类的clone()方法，并声明为public；
> 2. 在派生类的clone()方法中，调用super.clone()；
> 3. 派生类需实现Cloneable接口。

此时，Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类。

## [v1](v1) 使用原型模式来实现工作周报的快速创建

WeeklyLog充当具体原型类，Object类充当抽象原型类，clone()方法为原型方法。

## [v2](v2) 浅克隆(ShallowClone)和深克隆(DeepClone)

在Java语言中，数据类型分为值类型（基本数据类型）和引用类型，
值类型包括int、double、byte、boolean、char等简单数据类型，
引用类型包括类、接口、数组等复杂类型。

浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制

### [浅克隆](v2/shallow_clone)

> 在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；
如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，
也就是说原型对象和克隆对象的成员变量指向相同的内存地址。
简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，
而引用类型的成员对象并没有复制

### [深克隆](v2/deep_clone)

> 在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，
  深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，
  除了对象本身被复制外，对象所包含的所有成员变量也将复制
  
> 在Java语言中，如果需要实现深克隆，可以通过序列化(Serialization)等方式来实现。序列化就
  是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存
  中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此
  通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能
  够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。
  
## v3 原型管理器(Prototype Manager)

原型管理器(Prototype Manager)是将多个原型对象存储在一个集合中供客户端使用，
它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，
如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。
在原型管理器中针对抽象原型类进行编程，以便扩展。

## 总结

1. 主要优点
    > 1. 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。
    > 2. 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，
    增加或减少产品类对原有系统都没有任何影响。
    > 3. 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，
    而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。
    > 4. 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，
    以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。
2. 主要缺点
    > 1. 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，
    当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。
    > 2. 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，
    为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。